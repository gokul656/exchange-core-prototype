package org.malware.orderbook;

import lombok.Getter;
import lombok.SneakyThrows;
import org.malware.order.Order;
import org.malware.order.OrderBookEntry;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiPredicate;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static org.malware.order.OrderType.BUY;

@Getter
public class OrderBook implements IOrderBookEntry {

    private final ConcurrentHashMap<String, OrderBookEntry> orders = new ConcurrentHashMap<>();
    private final SortedSet<Level> bids = new TreeSet<>();
    private final SortedSet<Level> asks = new TreeSet<>();

    private final BiPredicate<Order, Order> hasEnoughQuantity =
            (orderOne, orderTwo) -> orderOne.getRemainingQuantity().compareTo(orderTwo.getRemainingQuantity()) >= 0;
    private final Predicate<Order> isFilled = (order) -> order.getRemainingQuantity().compareTo(BigDecimal.ZERO) == 0;

    @Override
    @SneakyThrows
    public void addOrder(Order order) {
        Level level = new Level(order.getPrice());
        Order savedOrder = addOrder(order, level, order.getOrderType() == BUY ? bids : asks, orders);
        match(savedOrder);
    }

    private Order addOrder(Order order, Level baseLevel, SortedSet<Level> levelLevels, ConcurrentHashMap<String, OrderBookEntry> internalOrderBook) {
        Level level = levelLevels.contains(baseLevel) ? levelLevels
                .stream()
                .filter(it -> it.price.equals(baseLevel.price))
                .findFirst()
                .orElse(null) : null;

        if (level != null) {
            OrderBookEntry orderBookEntry = new OrderBookEntry(order, baseLevel);

            if (level.head == null) {
                level.head = orderBookEntry;
            } else {
                OrderBookEntry tailPointer = level.tail;
                tailPointer.next = orderBookEntry;
                orderBookEntry.previous = tailPointer;
            }

            level.tail = orderBookEntry;
            internalOrderBook.put(order.getOrderId(), orderBookEntry);

            return orderBookEntry.currentOrder;
        } else {
            levelLevels.add(baseLevel);

            OrderBookEntry orderBookEntry = new OrderBookEntry(order, baseLevel);
            baseLevel.head = orderBookEntry;
            baseLevel.tail = orderBookEntry;

            internalOrderBook.put(order.getOrderId(), orderBookEntry);

            return orderBookEntry.currentOrder;
        }
    }

    @Override
    public void updateOrder(Order order) {

    }

    @Override
    public void removeOrder(String orderId) {
        OrderBookEntry orderBookEntry = orders.get(orderId);
        if (orderBookEntry != null) {
            removeOrder(orderId, orderBookEntry, orders);
        }
    }

    private void removeOrder(String orderId, OrderBookEntry orderBookEntry, ConcurrentHashMap<String, OrderBookEntry> internalOrderBook) {
        // Rewiring prev and next orders
        if (orderBookEntry.previous != null && orderBookEntry.next != null) {
            orderBookEntry.next.previous = orderBookEntry.previous;
            orderBookEntry.previous.next = orderBookEntry.next;
        } else if (orderBookEntry.previous != null) {
            orderBookEntry.previous.next = null;
        } else if (orderBookEntry.next != null) {
            orderBookEntry.next.previous = null;
        }

        if (orderBookEntry.parentLevel.head == orderBookEntry && orderBookEntry.parentLevel.tail == orderBookEntry) {
            // Deal with only one order
            orderBookEntry.parentLevel.head = null;
            orderBookEntry.parentLevel.tail = null;
        } else if (orderBookEntry.parentLevel.head == orderBookEntry) {
            // More than one order, but Orderbook entry is the first level
            orderBookEntry.parentLevel.head = orderBookEntry.next;
        } else if (orderBookEntry.parentLevel.tail == orderBookEntry) {
            // More than one order, but Orderbook entry is the first level
            orderBookEntry.parentLevel.tail = orderBookEntry.previous;
        }

        internalOrderBook.remove(orderId);
    }

    @Override
    public List<OrderBookEntry> getBuyOrders() {
        List<OrderBookEntry> orderBookEntries = new ArrayList<>();
        bids.forEach(
                bidLevel -> {
                    if (!bidLevel.isEmpty()) {
                        OrderBookEntry bidLimitPointer = bidLevel.head;
                        while (bidLimitPointer != null) {
                            orderBookEntries.add(bidLimitPointer);
                            bidLimitPointer = bidLimitPointer.next;
                        }
                    }
                }
        );

        return orderBookEntries;
    }

    @Override
    public List<OrderBookEntry> getSellOrders() {
        List<OrderBookEntry> orders = new ArrayList<>();
        asks.forEach(
                ask -> {
                    OrderBookEntry askLimitPointer = ask.head;
                    while (askLimitPointer != null) {
                        orders.add(askLimitPointer);
                        askLimitPointer = askLimitPointer.next;
                    }
                }
        );

        return orders;
    }

    @Override
    public MatchResult match() {
        return null;
    }

    @Override
    public MatchResult match(Order order) throws Exception {
        Set<Level> levels = Collections.synchronizedSet(asks);

        switch (order.getOrderMode()) {
            case MARKET:
                // Market order will be matched with best price
                processMarketOrder(order,order.getOrderType() == BUY ? asks : bids);
                break;
            case LIMIT:
                // Limit order will be matched with requested price
                processLimitOrder(order, order.getOrderType() == BUY ? asks : bids);
                break;
            default:
                throw new Exception("UNSUPPORTED ORDER MODE");
        }

        return null;
    }

    private void processMarketOrder(Order order, Set<Level> levels) {
        // Getting best trade
        Level bestLevel;

        if (!levels.isEmpty()) {
            if (order.getOrderType() == BUY) bestLevel = Collections.min(levels);
            else bestLevel = Collections.max(levels);

            if (!bestLevel.isEmpty()) {
                OrderBookEntry headPointer = bestLevel.head;
                while (headPointer != null) {
                    Order currentOrder = headPointer.currentOrder;
                    if (hasEnoughQuantity.test(order, currentOrder)) {
                        order.execQuantity = currentOrder.getRemainingQuantity();
                        currentOrder.execQuantity = currentOrder.getRemainingQuantity();

                        if (isFilled.test(order)) {
                            System.out.println("ORDER FILLED :: " + order.getOrderId());
                            removeOrder(order.orderId);
                        }

                        if (isFilled.test(currentOrder)) {
                            System.out.println("ORDER FILLED :: " + currentOrder.getOrderId());
                            removeOrder(currentOrder.orderId);
                        }
                    }

                    headPointer = headPointer.next;
                }
            }
        }
    }

    private void processLimitOrder(Order order, Set<Level> levels) {

        // TODO : replace with get exact price level function with binary search
        Set<Level> subLevels = levels.stream()
                .filter(level -> level.price.compareTo(order.getPrice()) <= 0)
                .collect(Collectors.collectingAndThen(
                        Collectors.toSet(),
                        list -> new TreeSet<>(list).descendingSet()));

        if (!subLevels.isEmpty()) {
            Level bestOrder = Collections.max(subLevels);
            OrderBookEntry headPointer = bestOrder.head;

            while (headPointer != null) {
                Order currentOrder = headPointer.currentOrder;
                if (hasEnoughQuantity.test(order, currentOrder)) {
                    order.execQuantity = currentOrder.getRemainingQuantity();
                    currentOrder.execQuantity = currentOrder.getRemainingQuantity();

                    if (isFilled.test(order)) {
                        removeOrder(order.orderId);
                        System.out.println("ORDER FILLED :: " + order.getOrderId());
                    }

                    if (isFilled.test(currentOrder)) {
                        removeOrder(currentOrder.orderId);
                    }
                }

                headPointer = headPointer.next;
            }
        }
    }
}
